#Huffman Coding is a greedy algorithm
Huffman Coding is a greedy algorithm used for lossless data compression.
It assigns shorter binary codes to more frequent characters and longer codes to less frequent ones to minimize the overall length of encoded data.

Hereâ€™s a concise step-by-step outline of the algorithm:

01.Calculate Character Frequencies: Count the frequency of each character in the input data.

02.Build a Priority Queue (Min-Heap): Insert all characters with their frequencies into a min-heap (priority queue), with the smallest frequency having the highest priority.

03.Construct the Huffman Tree:
While there is more than one node in the heap:
Extract the two nodes with the smallest frequencies.
Create a new internal node with these two nodes as children. The frequency of this new node is the sum of the frequencies of its children.
Insert the new node back into the heap.

04.Generate Huffman Codes: Once the tree is built, traverse it from the root to each leaf node to assign binary codes.
Left branches represent 0 and right branches represent 1.

05.Encode the Data: Replace each character in the input data with its corresponding Huffman code.

06.Decode the Data: To decode, traverse the Huffman Tree based on the binary code until you reach a leaf node (character).

Huffman Coding efficiently compresses data by reducing the average code length for characters, which is especially useful when some characters are more frequent than others.


#Why Use a Priority Queue?
 The Huffman coding algorithm requires repeatedly combining the two nodes with the smallest frequencies.
 The PriorityQueue (min-heap) is perfect for this because:

 ðŸ”¹Efficient Retrieval: The node with the smallest frequency can be accessed in constant time.
 ðŸ”¹Efficient Insertion and Removal: Insertion and removal of elements in a heap have a time complexity of O(log n), making these operations efficient as the heap size changes.

 Time Complexity:O(nlogn)
 Space Complexity: O(n)

